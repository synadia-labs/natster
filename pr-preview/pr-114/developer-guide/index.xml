<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Developer Guide on Natster</title><link>https://docs.natster.io/pr-preview/pr-114/developer-guide/</link><description>Recent content in Developer Guide on Natster</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><atom:link href="https://docs.natster.io/pr-preview/pr-114/developer-guide/index.xml" rel="self" type="application/rss+xml"/><item><title>Architecture Overview</title><link>https://docs.natster.io/pr-preview/pr-114/developer-guide/architecture/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://docs.natster.io/pr-preview/pr-114/developer-guide/architecture/</guid><description>Natster Global Account The Natster Global Service Synadia Hub Account Natster.IO Account User Accounts User Catalog Imports/Exports The Natster architecture relies heavily on NATS decentralized accounts as security boundaries. Each user enables Natster within their Synadia Cloud account. This creates a few automatic subject imports for things like the synadiahub catalog and the Natster global service.
The following diagram provides a layout showing how various components interact with each other.</description></item><item><title>Decentralized Auth</title><link>https://docs.natster.io/pr-preview/pr-114/developer-guide/decentralized-security/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://docs.natster.io/pr-preview/pr-114/developer-guide/decentralized-security/</guid><description>Rather than build its own security and user account tier like we have to do with most applications, Natster utilizes NATS&amp;rsquo; decentralized authn/authz directly. A Natster account is an NGS account (which is a NATS account). Natster authenticates to Synadia Cloud using JSON Web Tokens (JWT) and seeds.
Traditionally, when we get asked to build an application out of a suite of microservices, we might add services to deal with authentication and authorization.</description></item><item><title>Secure Sharing</title><link>https://docs.natster.io/pr-preview/pr-114/developer-guide/secure-sharing/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://docs.natster.io/pr-preview/pr-114/developer-guide/secure-sharing/</guid><description>In this section of the documentation, we&amp;rsquo;ll cover how Natster enables incredibly tight security around sharing without having to write much security code at all. The NATS import/export system that comes with decentralized authentication and accounts does all the hard work for us.
Let&amp;rsquo;s take a look at a simple example of how two users might share with each other using Natster. Alice has a catalog full of Rust videos that she would like to share with Bob.</description></item><item><title>Global Service</title><link>https://docs.natster.io/pr-preview/pr-114/developer-guide/global-service/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://docs.natster.io/pr-preview/pr-114/developer-guide/global-service/</guid><description>The global service does not manage any of your sensitive information other than holding onto the last personal access token you used so that it can make Synadia Cloud API requests on your behalf. We don&amp;rsquo;t want any personal information and nearly all data stored is just reference keys and aggregate statistics to power our dashboard.
Your catalog contents are never queried, stored, or cached by this service.
The Natster global service is consumed by the natster CLI and nearly every function outlined in the API below can be invoked from the CLI.</description></item><item><title>Catalog Server</title><link>https://docs.natster.io/pr-preview/pr-114/developer-guide/catalog-server/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://docs.natster.io/pr-preview/pr-114/developer-guide/catalog-server/</guid><description>The catalog server is a daemon process that you can run anywhere that has direct access to the files that make up a given catalog. This means you could run it on a Raspberry Pi connected to network storage or you could run it in the cloud pointing at an EBS volume, or, more commonly, you could run the service in your own infrastructure to ensure your files are never stored outside your own environment.</description></item><item><title>Context Binding (OTC)</title><link>https://docs.natster.io/pr-preview/pr-114/developer-guide/context-binding/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://docs.natster.io/pr-preview/pr-114/developer-guide/context-binding/</guid><description>The core job of context binding is to merge the two contexts or mediums together to provide a single unified experience: web and CLI. When you log into our web application, you do so via OAuth. This means the website gets no information that you don&amp;rsquo;t allow, and is usually just an opaque unique identifier issued by an identity provider.
Natster Init Natster init takes your Synadia Cloud context, indicated by your personal access token.</description></item><item><title>Nothing but NATS</title><link>https://docs.natster.io/pr-preview/pr-114/developer-guide/nothing-but-nats/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://docs.natster.io/pr-preview/pr-114/developer-guide/nothing-but-nats/</guid><description>&amp;ldquo;Nothing but NATS&amp;rdquo; is a philosophy of building applications where we rely on primitives available in NATS for everything we need, eschewing traditional costly, difficult, and complicated cloud products. Some of us treat this philosophy more like a way of life (the ÈÅì Dao of NATS?)
Security Probably the largest return on investment from this philosophy for Natster is in the area of security. By using NATS decentralized authentication and authorization as a core part of the Natster sharing mechanics, we got a tremendous amount of features and functionality for free.</description></item><item><title>Streaming Media</title><link>https://docs.natster.io/pr-preview/pr-114/developer-guide/streaming-media/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://docs.natster.io/pr-preview/pr-114/developer-guide/streaming-media/</guid><description>When we originally designed Natster, streaming media was a stretch goal. We planned on supporting single downloads via file chunking and that was all. But because Natster leveraged so much underlying NATS technology, we ended up ahead of schedule, and so had time to explore streaming media.
The natster.io website supports streaming video/mp4 content from catalogs to which you have access. This means that you can log into Natster on your phone and watch the latest videos and tutorials from Synadia.</description></item><item><title>Global Event Log</title><link>https://docs.natster.io/pr-preview/pr-114/developer-guide/global-event-log/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://docs.natster.io/pr-preview/pr-114/developer-guide/global-event-log/</guid><description>Some portions of the Natster application are what we would call event-sourced. Since the entire application doesn&amp;rsquo;t operate this way (because of time constraints as we worked toward a Kubecon demo release), we&amp;rsquo;ll call it event-sourcey.
The short1 definition of event sourced is that rather than managing an application&amp;rsquo;s state by storing the current values of everything, we instead derive that state from a series of immutable events. We want to know why and how we arrived at a given state and, even more importantly, we want to be able to change the state we store without altering our record of the past.</description></item><item><title>Troubleshooting</title><link>https://docs.natster.io/pr-preview/pr-114/developer-guide/troubleshooting/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://docs.natster.io/pr-preview/pr-114/developer-guide/troubleshooting/</guid><description>Coming soon!</description></item></channel></rss>